import argparse
import hashlib
import logging
import pprint
import re
import subprocess
import sys
import pathlib
from collections import Counter

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)


BUILD_HEADER = '''import pathlib
import sys

import nametable_builder

"""
This script has been generated by nametable_builder.py.  It's intended to rebuild the nametable
into a .bin

Unless modified, it will reproduce the original.
"""

file = pathlib.Path(__file__)
output = file.parent / file.name.replace(".py", ".bin")
'''

BUILD_FOOTER = """
if __name__ == "__main__":
    try:
        nametable_builder.build_nametable(
            output,
            table,
            attributes,
            characters,
            original_sha1sum,
            lengths,
            starting_addresses,
        )
    except Exception as exc:
        print(
            f"Unable to build nametable: {type(exc).__name__}: {exc!s}", file=sys.stderr
        )
        sys.exit(1)"""

FINDALL_NON_NEWLINES = re.compile(r"[^\n]").findall


class Args(argparse.Namespace):
    action: str
    output: str
    nametable: str
    characters: str
    skip_attrs: bool


def extract_bytes_from_nametable(
    nametable_filename: str,
) -> tuple[list[tuple[int, int]], list[int], list[int], str]:
    """
    Read nametable and return a list of starting addresses as tuples, a list of lengths, and another list of the raw data
    """
    start_addresses = []
    lengths = []
    data = []
    nametable = open(nametable_filename, "rb").read()
    logger.debug(f"Original file length is {len(nametable)}")
    original_sha1sum = hashlib.sha1(nametable).hexdigest()
    logger.info(f"Original sha1sum is {original_sha1sum}")

    with open(nametable_filename, "rb") as file:
        while True:
            chunk = file.read(3)
            if not chunk or chunk == b"\xff":
                break
            logging.debug(f"chunk: {chunk!r}")
            start_address = tuple(chunk[0:2])
            start_addresses.append(start_address)
            length = chunk[2]
            lengths.append(length)
            data.extend(list(file.read(length)))
    logger.debug(f"Read {len(start_addresses)} starting addresses")
    logger.debug(f"Read {len(lengths)} lengths")
    logger.debug(f"Read {len(data)} data")
    return (
        start_addresses,
        lengths,
        data,
        original_sha1sum,
    )


def validate_attribute_length(attributes: list[int]):
    attribute_len = len(attributes)
    if attribute_len != 64:
        print(
            f"Expected length of attribute table is 64 bytes.  Received {attribute_len}",
            file=sys.stderr,
        )
        sys.exit(1)


def break_out_attribute_table(attributes: list[int]) -> list[str]:
    validate_attribute_length(attributes)
    results = []
    for row_index in range(0, 57, 8):
        line1 = ""
        line2 = ""
        for byte in attributes[row_index : row_index + 8]:
            top_left = byte & 0b00000011
            top_right = (byte & 0b00001100) >> 2
            bottom_left = (byte & 0b00110000) >> 4
            bottom_right = (byte & 0b11000000) >> 6
            line1 += f"{top_left}{top_right}"
            line2 += f"{bottom_left}{bottom_right}"
        results.append(line1)
        results.append(line2)
    return results


def restore_attribute_table(attr_table):
    attributes = re.findall("[0123]", attr_table)
    if not attributes:
        return []

    attrs = []
    for row in range(0, len(attributes), 32):
        data = attributes[row : row + 32]
        line1 = data[:16]
        line2 = data[16:]
        for i in range(0, 16, 2):
            tl = int(line1[i])
            tr = int(line1[i + 1]) << 2
            bl = int(line2[i]) << 4
            br = int(line2[i + 1]) << 6
            byte = br | bl | tr | tl
            attrs.append(byte)
    validate_attribute_length(attrs)
    return attrs


def format_characters(characters_raw: str):
    output = []
    output.append("characters = (")
    output.append("    #0123456789ABCDEF")
    for i, line in enumerate(characters_raw.splitlines()):
        index = f"#{i:x}".upper()
        output.append(f'    "{line}" {index}')
    output.append(")  # fmt: skip")
    return "\n".join(output)


def break_nametable_from_args(args: Args):
    logger.debug(f"Opening characters file {args.characters}")
    characters_raw = open(args.characters).read()
    logger.debug(f"characters is {len(characters_raw)} characters long")

    starting_addresses, lengths, data, original_sha1sum = extract_bytes_from_nametable(
        args.nametable
    )

    output_file = args.output or args.nametable.replace(".bin", ".py")
    break_nametable(
        output_file,
        starting_addresses,
        data,
        lengths,
        original_sha1sum,
        args.skip_attrs,
        characters_raw,
    )


def break_nametable(
    output_file: str,
    starting_addresses: list[tuple[int, int]],
    data: list[int],
    lengths: list[int],
    original_sha1sum: str,
    skip_attrs: bool,
    characters_raw: str,
):
    characters = FINDALL_NON_NEWLINES(characters_raw)
    validate_characters(characters)
    logger.debug(f"characters length is {len(characters)}")

    attributes_output = []
    if not skip_attrs:
        attributes_raw = data[-64:]
        attributes_output = break_out_attribute_table(attributes_raw)
        data = data[:-64]

    nametable_output = []
    for length in lengths:
        row = data[:length]
        data = data[length:]
        text_row = "".join(characters[byte] for byte in row)
        nametable_output.append(text_row)

    with open(output_file, "w+") as file:
        print(BUILD_HEADER, file=file)

        print(f'original_sha1sum = "{original_sha1sum}"\n', file=file)

        print(format_characters(characters_raw), end="\n\n", file=file)

        print(f'table = """', file=file)
        print("\n".join(nametable_output), end='"""\n\n', file=file)

        print(f'attributes = """', file=file)
        print("\n".join(attributes_output), end='"""\n\n', file=file)

        print(
            f"lengths = {pprint.pformat(lengths, compact=True)}  # fmt: skip\n",
            file=file,
        )

        print(
            f"starting_addresses = {pprint.pformat(starting_addresses, compact=True)}  # fmt: skip\n",
            file=file,
        )

        print(BUILD_FOOTER, file=file)


def get_reverse_index(
    characters: str,
) -> dict[str, int]:
    index = FINDALL_NON_NEWLINES(characters)
    return {c: i for i, c in enumerate(index)}


def validate_characters(characters: list[str]):
    characters_len = len(characters)
    if characters_len != 256:
        print(
            f"Characters text needs 256 characters.  Received {characters_len}",
            file=sys.stderr,
        )
        sys.exit(1)
    unique_characters_len = len(set(characters))
    if unique_characters_len != 256:
        count = Counter(characters)
        duplicates = [k for k, v in count.items() if v > 1]
        print(
            f"Characters text needs 256 unique character.  Duplicates: {duplicates!r}",
            file=sys.stderr,
        )
        sys.exit(1)


def build_nametable(
    output: str | pathlib.Path,
    table: str,
    attributes: str,
    characters: str,
    original_sha1sum: str,
    lengths: list[int],
    starting_addresses: list[tuple[int, int]],
    rle_compress: bool = False,
    rects=None,
) -> None:
    if rects is None:
        rects = []
    validate_characters(characters)
    logger.debug(f"Read {len(lengths)} lengths")
    logger.debug(f"Read {len(starting_addresses)} starting addresses")

    attribute_bytes = restore_attribute_table(attributes)
    logger.debug(f"Read {len(attribute_bytes)} bytes from attributes")

    table_chars = re.findall(r"[^\n]", table)
    reverse_index = get_reverse_index(characters)
    table_bytes = [reverse_index[t] for t in table_chars]
    logger.debug(f"Read {len(table_bytes)} bytes from table")

    table_bytes.extend(attribute_bytes)
    logger.debug(f"Read {len(table_bytes)} bytes total")
    for rect in rects:
        draw_rect(table_bytes, *rect)

    if rle_compress:
        output_data = konami_compress(table_bytes)
    else:
        output_bytes = []
        for length, starting_address in zip(lengths, starting_addresses):
            output_bytes.extend(starting_address)
            output_bytes.append(length)
            output_bytes.extend(table_bytes[:length])
            table_bytes = table_bytes[length:]

        output_bytes.append(255)
        output_data = bytes(output_bytes)

    sha1sum = hashlib.sha1(output_data).hexdigest()
    if sha1sum != original_sha1sum:
        logger.warning(f"Warning! {sha1sum} does not match original {original_sha1sum}")
    else:
        logger.debug(f"Original nametable being rebuilt")

    with open(output, "wb") as file:
        file.write(output_data)


def draw_rect(buffer, x, y, w, h, offset):
    """
    credit to kirjava
    function drawRect(buffer, x, y, w, h, offset) {
        x += 3;
        const pixel = x+ (y*32);
        for (let i=0;w>i;i++) {
            for (let j=0;h>j;j++) {
                buffer[pixel + i + (j * 32)] = offset+i + (j * 0x10);
            }
        }
    }
    """
    x += 3
    pixel = x + (y * 32)
    for i in range(w):
        for j in range(h):
            buffer[pixel + i + (j * 32)] = offset + i + (j * 0x10)


def konami_compress(buffer) -> bytes:
    """
    credit to kirjava
    function konamiComp(buffer) {
        const compressed = [];

        for (let i = 0; i < buffer.length;) {
            const byte = buffer[i];

            // count extra dupes
            let peek = 0;
            for (;byte ==buffer[i+1+peek];peek++);
            const count = Math.min(peek + 1, 0x80);

            if (peek > 0) {
                compressed.push([count, byte]);
                i+= count;
            } else {
                // we have already peeked the next byte and know it's not a double
                // so start checking from there
                const start = i + 1;
                const nextDouble = buffer.slice(start, start + 0x7F)
                    .findIndex((d,i,a)=>d==a[i+1]);

                const count = Math.min(nextDouble === -1
                    ? buffer.length - i
                    : nextDouble + 1, 0x7F);

                compressed.push([0x80 + count, buffer.slice(i, count + i)]);
                i += count;
            }
        }

        compressed.push(0xFF);

        return compressed.flat(Infinity);
    }
    """
    compressed = []
    i = 0
    while i < len(buffer):
        byte = buffer[i]

        # count duplicates
        peek = 0
        while True:
            if i + peek + 1 == len(buffer) or peek == 0x80:
                break
            if byte == buffer[i + peek + 1]:
                peek += 1
            else:
                break
        count = min(peek + 1, 0x80)
        if peek:
            compressed.extend([count, byte])
            i += count
            continue

        # count non duplicates
        start = i + 1
        for count, check in enumerate(buffer[i : i + 0x7F]):
            if i + count + 1 == len(buffer):
                break
            if check == buffer[i + count + 1]:
                break
        compressed.append(0x80 + count)
        compressed.extend(buffer[i : i + count])
        i += count

    return bytes(compressed + [0xFF])


def get_args():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(required=True, dest="action")

    break_parser = subparsers.add_parser(
        "break",
        help="Break a nametable into a .py file",
    )

    break_parser.add_argument(
        "nametable",
        help="Filename of nametable",
    )

    break_parser.add_argument(
        "characters",
        type=str,
        help="Text file that contains 256 unique characters (newlines ignored)",
    )

    break_parser.add_argument(
        "--output",
        type=str,
        help="Output .py file.  Will be the same as input but with extension changed if not specified",
    )

    break_parser.add_argument(
        "--skip-attrs",
        action="store_true",
        help="Do not break out the last 64 bytes as attr table",
    )

    namespace = Args()
    return parser.parse_args(namespace=namespace)


def main():
    actions = {
        "break": break_nametable_from_args,
    }
    args = get_args()
    actions[args.action](args)


if __name__ == "__main__":
    main()
